from test_sets.stories.story_globals import OFFLOAD_PATTERN_100_0, OFFLOAD_PATTERN_100_10, \
    STORY_TYPE_LINK_ID, STORY_TYPE_OFFLOAD, STORY_TYPE_SETUP
from test_sets.stories.story_setup_functions import gen_hybrid_drop_ddl, drop_backend_test_table,\
    gen_range_range_vc_dt_subpartitioned_fact_ddl, gen_range_range_yrmon_subpartitioned_fact_ddl,\
    gen_sales_based_subpartitioned_fact_ddl, gen_sales_based_subpartitioned_mcol_fact_ddl
from test_sets.stories.story_assertion_functions import backend_table_count, offload_fact_assertions, \
    offload_lpa_fact_assertion

from goe.gluent import OFFLOAD_TYPE_CHANGE_FOR_SUBPART_EXCEPTION_TEXT
from goe.offload.oracle.oracle_column import ORACLE_TYPE_VARCHAR2
from goe.offload.offload_constants import DBTYPE_BIGQUERY, PART_COL_GRANULARITY_DAY
from goe.offload.offload_functions import convert_backend_identifier_case
from goe.offload.offload_metadata_functions import OFFLOAD_TYPE_FULL, OFFLOAD_TYPE_INCREMENTAL, \
    INCREMENTAL_PREDICATE_TYPE_LIST


FACT_RANGE_RANGE = 'story_sp_rr'
FACT_RANGE_RANGE_YR = 'story_sp_rr_yr'
FACT_MCOL = 'STORY_SP_MCOL'
FACT_LIST_RANGE = 'story_sp_lr'
FACT_HASH_RANGE = 'story_sp_hr'


def offload_subpart_mcol_init_options(schema, table_name, options):
    opts = {'owner_table': schema + '.' + table_name,
            'reset_backend_table': True,
            'offload_by_subpartition': True,
            'less_than_value': '2012,2,1',
            'offload_partition_granularity': '1,1,1'}
    if options and options.target == DBTYPE_BIGQUERY:
        opts.update({'offload_partition_columns': 'time_id',
                     'offload_partition_granularity': PART_COL_GRANULARITY_DAY})
    return opts


def offload_subpart_story_tests(schema, hybrid_schema, data_db, options, backend_api, frontend_api, repo_client):
    fact_mcol = convert_backend_identifier_case(options, FACT_MCOL)
    return [
        {'id': 'offload_subpart_fact_setup1',
         'type': STORY_TYPE_SETUP,
         'title': 'Create %s' % FACT_LIST_RANGE,
         'setup': {'oracle': gen_sales_based_subpartitioned_fact_ddl(schema, FACT_LIST_RANGE),
                   'hybrid': gen_hybrid_drop_ddl(options, frontend_api, hybrid_schema, [FACT_LIST_RANGE]),
                   'python': [lambda: drop_backend_test_table(options, backend_api, data_db, FACT_LIST_RANGE)]}},
        {'id': 'offload_subpart_fact_init',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial Offload of Range Subpartitioned Fact',
         'narrative': 'Offloads some partitions from a range subpartitioned fact table. offload_fact_assertions() will check that TIME_ID is the incremental key even though that is the subpartitioned key',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'reset_backend_table': True,
                     'offload_by_subpartition': True,
                     'older_than_date': '2012-02-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, '2012-02-01',
                                                    incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_fact_1st_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental Offload of Subpartitioned Fact',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'older_than_date': '2012-03-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, '2012-03-01',
                                                    incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_bad_hwm1',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental Offload of Subpartitioned Fact (Expect to Fail)',
         'narrative': 'This test chooses a HWM that is not common across all list partition values and therefore should throw an exception',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'older_than_date': '2012-04-01'},
         'expected_exception_string': 'common boundary'},
        {'id': 'offload_subpart_2nd_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental Offload of Subpartitioned Fact',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'older_than_date': '2012-05-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, '2012-05-01',
                                                    incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_bad_hwm2',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental Offload of Subpartitioned Fact (Expect to Fail)',
         'narrative': 'This test chooses the final HWM in the table and therefore should throw an exception',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'older_than_date': '2012-07-01'},
         'expected_exception_string': '--offload-type=FULL'},
        {'id': 'offload_subpart_full',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Offload Type FULL of Subpartitioned Fact',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'offload_type': OFFLOAD_TYPE_FULL},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, None,
                                                    incremental_range='SUBPARTITION',
                                                    offload_pattern=OFFLOAD_PATTERN_100_0)},
        {'id': 'offload_subpart_switch_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Offload Type FULL->INCREMENTAL of Subpartitioned Fact (Expect to Fail)',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'offload_type': OFFLOAD_TYPE_INCREMENTAL},
         'expected_exception_string': OFFLOAD_TYPE_CHANGE_FOR_SUBPART_EXCEPTION_TEXT},
        {'id': 'offload_subpart_100_10',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Offload Type 100/0 to 100/10 on Subpartitioned Fact',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'older_than_date': '2012-05-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, '2012-05-01',
                                                    incremental_range='SUBPARTITION',
                                                    offload_pattern=OFFLOAD_PATTERN_100_10)},
        {'id': 'offload_subpart_fact_setup2',
         'type': STORY_TYPE_LINK_ID,
         'linked_id': 'offload_subpart_fact_setup1'},
        {'id': 'offload_subpart_fact_lpa_init',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial LPA Offload of Same List/Range Fact',
         'narrative': 'Confirms that an Offload of FACT_LIST_RANGE using LPA options gives us a top level LIST offload and not subpartition RANGE',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'reset_backend_table': True,
                     'equal_to_values': ['2'],
                     'offload_partition_lower_value': 0,
                     'offload_partition_upper_value': 10},
         'assertion_pairs': [
             (lambda test: offload_lpa_fact_assertion(test, schema, hybrid_schema, data_db, FACT_LIST_RANGE,
                                                      options, backend_api, frontend_api, repo_client,
                                                      ['2'], check_rowcount=True,
                                                      incremental_predicate_type=INCREMENTAL_PREDICATE_TYPE_LIST),
              lambda test: True)]},
        {'id': 'offload_subpart_fact_lpa_1st_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental LPA Offload of Subpartitioned Fact',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'equal_to_values': ['3']},
         'assertion_pairs': [
             (lambda test: offload_lpa_fact_assertion(test, schema, hybrid_schema, data_db, FACT_LIST_RANGE,
                                                      options, backend_api, frontend_api, repo_client,
                                                      ['2', '3'], check_rowcount=True,
                                                      incremental_predicate_type=INCREMENTAL_PREDICATE_TYPE_LIST),
              lambda test: True)]},
        {'id': 'offload_subpart_fact_lpa_full_init',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Full Offload of Same List/Range Fact',
         'narrative': 'Confirms that an Offload with no filters results in FULL',
         'options': {'owner_table': schema + '.' + FACT_LIST_RANGE,
                     'offload_partition_lower_value': 0,
                     'offload_partition_upper_value': 10,
                     'reset_backend_table': True},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_LIST_RANGE, None,
                                                    incremental_range='PARTITION',
                                                    offload_pattern=OFFLOAD_PATTERN_100_0)},
        {'id': 'offload_subpart_rr_vc_dt_setup',
         'type': STORY_TYPE_SETUP,
         'title': 'Create story_sp_rr',
         'setup': {'oracle': gen_range_range_vc_dt_subpartitioned_fact_ddl(schema, FACT_RANGE_RANGE),
                   'hybrid': gen_hybrid_drop_ddl(options, frontend_api, hybrid_schema, FACT_RANGE_RANGE),
                   'python': [lambda: drop_backend_test_table(options, backend_api, data_db, FACT_RANGE_RANGE)]}},
        {'id': 'offload_subpart_rr_vc_dt_offload1',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Offload of RANGE/RANGE VC2/DATE Fact',
         'narrative': 'Offload a RANGE/RANGE VC2/DATE table, will offload at top level RANGE',
         'options': {'owner_table': schema + '.' + FACT_RANGE_RANGE,
                     'reset_backend_table': True,
                     'less_than_value': '3',
                     'offload_partition_granularity': '1'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_RANGE_RANGE, '3',
                                                    incremental_range='PARTITION', incremental_key='CHANNEL_ID',
                                                    incremental_key_type=ORACLE_TYPE_VARCHAR2)},
        {'id': 'offload_subpart_rr_vc_dt_offload2',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Offload of RANGE/RANGE VC2/DATE Fact',
         'narrative': 'Offload a RANGE/RANGE VC2/DATE table using option to offload at subpart level RANGE',
         'options': {'owner_table': schema + '.' + FACT_RANGE_RANGE,
                     'reset_backend_table': True,
                     'older_than_date': '2012-02-01',
                     'offload_by_subpartition': True},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_RANGE_RANGE, '2012-02-01',
                                                    incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_rr_yrmon_setup',
         'type': STORY_TYPE_SETUP,
         'title': 'Create story_subp_fact',
         'narrative': 'This is actually a poor example because in this case we\'d need to be able to offload by both partition and subpartition HWM!',
         'setup': {'oracle': gen_range_range_yrmon_subpartitioned_fact_ddl(schema, FACT_RANGE_RANGE_YR),
                   'hybrid': gen_hybrid_drop_ddl(options, frontend_api, hybrid_schema, FACT_RANGE_RANGE_YR),
                   'python': [lambda: drop_backend_test_table(options, backend_api, data_db, FACT_RANGE_RANGE_YR)]}},
        {'id': 'offload_subpart_rr_yrmon_init',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial Offload of Range/Range Subpartitioned Fact 2',
         'narrative': 'Offloads a RANGE/RANGE subpartitioned table that requests manually inclusion of --offload-by-subpartition',
         'options': {'owner_table': schema + '.' + FACT_RANGE_RANGE_YR,
                     'reset_backend_table': True,
                     'less_than_value': 2,
                     'offload_partition_granularity': '1',
                     'offload_partition_lower_value': 0,
                     'offload_partition_upper_value': 4000,
                     'offload_by_subpartition': True},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_RANGE_RANGE_YR, '2',
                                                    incremental_key='MON', incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_rr_yrmon_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incr Offload of Range/Range Subpartitioned Fact 2',
         'narrative': 'Offloads to a RANGE/RANGE subpartitioned table without manual inclusion of --offload-by-subpartition',
         'options': {'owner_table': schema + '.' + FACT_RANGE_RANGE_YR,
                     'less_than_value': 3},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_RANGE_RANGE_YR, '3',
                                                    incremental_key='MON', incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_mcol_setup',
         'type': STORY_TYPE_SETUP,
         'title': 'Create story_sp_mcol',
         'setup': {'oracle': gen_sales_based_subpartitioned_mcol_fact_ddl(schema, FACT_MCOL),
                   'hybrid': gen_hybrid_drop_ddl(options, frontend_api, hybrid_schema, FACT_MCOL),
                   'python': [lambda: drop_backend_test_table(options, backend_api, data_db, fact_mcol)]}},
        {'id': 'offload_subpart_mcol_init',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial Offload of Range Subpartitioned Multi Col Fact',
         'narrative': 'Offloads some subpartitions from a range subpartitioned fact table with multi-column subpartitioning',
         'options': offload_subpart_mcol_init_options(schema, FACT_MCOL, options)},
        {'id': 'offload_subpart_mcol_incr',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Incremental Offload of Range Subpartitioned Multi Col Fact',
         'options': {'owner_table': schema + '.' + FACT_MCOL,
                     'less_than_value': '2012,3,1'},
         'assertion_pairs': [(lambda test: frontend_api.get_table_row_count(schema, FACT_MCOL,
                                                                            filter_clause='YR<2012 OR (YR=2012 AND MON<3) OR (YR=2012 AND MON=3 AND DY<1)'),
                              lambda test: backend_table_count(backend_api, data_db, fact_mcol))]},
        {'id': 'offload_subpart_hr_setup1',
         'type': STORY_TYPE_SETUP,
         'title': 'Create %s' % FACT_HASH_RANGE,
         'setup': {'oracle': gen_sales_based_subpartitioned_fact_ddl(schema, FACT_HASH_RANGE, top_level='HASH'),
                   'hybrid': gen_hybrid_drop_ddl(options, frontend_api, hybrid_schema, FACT_HASH_RANGE),
                   'python': [lambda: drop_backend_test_table(options, backend_api, data_db, FACT_HASH_RANGE)]}},
        {'id': 'offload_subpart_hr_offload1',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial Offload of Range Subpartitioned Fact',
         'narrative': 'Offloads some partitions from a range subpartitioned fact table. Expect subpartition offload purely because we used older_than_date',
         'options': {'owner_table': schema + '.' + FACT_HASH_RANGE,
                     'reset_backend_table': True,
                     'older_than_date': '2012-02-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_HASH_RANGE, '2012-02-01',
                                                    incremental_range='SUBPARTITION')},
        {'id': 'offload_subpart_hr_offload2',
         'type': STORY_TYPE_OFFLOAD,
         'title': 'Initial Offload of Range Subpartitioned Fact',
         'narrative': 'Offloads some partitions from a range subpartitioned fact table. Expect subpartition offload purely because we used older_than_date',
         'options': {'owner_table': schema + '.' + FACT_HASH_RANGE,
                     'reset_backend_table': True,
                     'older_than_date': '2012-03-01'},
         'assertion_pairs': offload_fact_assertions(options, backend_api, frontend_api, repo_client,
                                                    schema, hybrid_schema, data_db, FACT_HASH_RANGE, '2012-03-01',
                                                    incremental_range='SUBPARTITION')},
    ]
